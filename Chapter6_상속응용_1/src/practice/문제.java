package practice;

public class 문제 {
/*
1.자바의 상속에 대한 설명 중 틀린 것은?
1) 자바는 다중 상속을 허용한다.(단일 상속) //인터페이스는 다중 구현
-----------------------자바 class => 상속 / interface => 구현
2) 부모의 메소드를 자식 클래스에서 재정의(오버라이딩)할 수 있다.
3) 부모의 private 접근 제한을 갖는 필드와 메소드는 상속의 대상이 아니다.
   static, 생성자, 초기화블럭, private(상속은 된다. 단지 접근이 안된다)
   => 상속의 예외 조건
4) final 클래스는 상속할 수 없고, final 메소드는 오버라이딩 할 수 없다.
   final이 있는 경우 있는 그대로 사용 => String, Math, System...
   
  
2.클래스 타입 변환에 대한 설명 중 틀린 것은?
  class 동물
  class 사람 extends 동물 => 동물 a = new 사람();
                          사람 b = new 사람();
                           B bb =(B)a;
  
1) 자식 객체는 부모 타입으로 자동 타입 변환된다.
2) 부모 객체는 항상 자식 타입으로 강제 타입 변환된다.
---------------------------------------
3) 자동 타입 변환을 이용해서 필드와 매개 변수의 다형성을 구현한다.
4) 강제 타입 변환 전에 instanceof 연산자로 변환 가능한지 검사하는 것이 좋다.
  
  
3.final 키워드에 대한 설명으로 틀린 것은?
 
1) final 클래스는 부모 클래스로 사용할 수 있다. => fianl클래스는 상속이 불가능
------------------------------------
2) final 필드는 값이 저장된 후에는 변경할 수 없다.
3) final 메소드는 재정의(오버라이딩)할 수 없다.
4) static final 필드는 상수를 말한다.
final => 상수형 변수
static final => 상수
  
  
4.오버라이딩(Overriding)에 대한 설명으로 틀린 것은?
  
1) 부모 메소드의 시그너처(리턴 타입, 메소드명, 매개 변수)와 동일해야 한다.
2) 부모 메소드보다 좁은 접근 제한자를 붙일 수 없다.(ex. public > private)
3) @Override 어노테이션을 사용하면 재정의가 확실한지 컴파일러가 검증한다.
4) protected 접근 제한을 갖는 메소드는 다른 패키지의 자식 클래스에서 재정의할 수 없다.
-----------------------------------------------------------------
  
5. Parent 클래스를 상속한 Child 클래스의 생성자에서 컴파일 에러가 발생한 이유는?

public class Parent{
	public String name;
	---------------------
    public Parent(){} ==> 기본 생성자가 있어야한다.
    --------------------- 
	public Parent(String name){
		this.name = name;
	}
}
 
public class Child extends Parent{
	private int studentNo;
 
	public Child(String name, int studentNo){
		this.name = name;
		this.studentNo = studentNo;
	}
}
------------------------------------------------------------ 
1) 생성자는 상속이 되지 않는다.
2) Child c = new Child("",1)=>  상위 클래스의 기본 생성자가 호출된다.
------------------------------------------------------------

7. 인터페이스에 대한 설명으로 틀린 것은 무엇입니까?
 
1. 인터페이스는 객체 사용 설명서 역할을 한다.
2. 구현 클래스가 인터페이스의 추상 메소드에 대한 실체 메소드를 가지고 있지 않으면 추상 클래스가 된다.
3. 인터페이스는 인스턴스 필드를 가질 수 있다. (상수형 변수만 가질 수 있다.)
----------------------------------
   public static final
4. 구현 객체는 인터페이스 타입으로 자동 변환된다.
*멤버변수 => 필드, 속성(인스턴스 변수)

 
8. 인터페이스의 다형성과 거리가 먼 것은? 
 
1. 필드가 인터페이스 타입일 경우 다양한 구현 객체를 대입할 수 있다.
2. 매개 변수가 인터페이스 타입일 경우 다양한 구현 객체를 대입할 수 있다.
3. 배열이 인터페이스 타입일 경우 다양한 구현 객체를 저장할 수 있다.
4. 구현 객체를 인터페이스 타입으로 변환하려면 강제 타입 변환을 해야 한다. => 자동형변환이 된
----------------------------------------------------     interface A                 - 참조타입 변수
                                                         class B implements A   => A a = new B();
                                                                                  --인터페이스 타입 
1.참조 타입에 대한 설명으로 틀린 것은 무엇입니까?                                              (참조타입)

① 참조 타입에는 배열, 열거, 클래스, 인터페이스가 있다.
② 참조 타입 변수의 메모리 생성 위치는 스택이다.
③ 참조 타입에서 ==, != 연산자는 객체 번지를 비교한다.
④ 참조 타입은 null 값으로 초기화 할 수 없다.
----------------------------------
A a = null; 할수있다.


2. 자바에서 메모리 사용에 대한 설명으로 틀린 것은 무엇입니까?

① 로컬 변수는 스택 영역에 생성되며 실행 블록이 끝나면 소멸된다.
② 메소드 코드나, 상수, 열거 상수는 정적(메소드) 영역에 생성된다.
③ 참조되지 않는 객체는 프로그램에서 직접 소멸 코드를 작성하는 것이 좋다.
-----------------------------------------------------
  => 자동 메모리 회수를 이용한다(GC)
  => 멀티미디어 프로그램(화상채팅, CCTV...)
④ 배열 및 객체는 힙 영역에 생성된다.


3. String 타입에 대한 설명으로 틀린 것은 무엇입니까?

① String은 클래스이므로 참조 타입이다. => 클래스형(참조타입)
  => 메소드
  => 문자열 데이터형, 클래스 참조형
② String 타입의 문자열 비교는 == 를 사용해야 한다.
---------------------------------------
  ==을 사용하면 주소값을 비교
  String s = "Hello"
  String s1 = new String("Hello")
  if(s==s1) false
  if(s.equals(s1))
③ 동일한 문자열 리터럴을 저장하는 변수는 동일한 String 객체를 참조한다.
  String s1 = "Hello"
  String s2 = "Hello"
  if(s1==s2) true
④ new String("문자열")은 문자열이 동일하더라도 다른 String 객체를 생성한다.


4. 인터페이스에 대한 설명으로 틀린 것은 무엇입니까?

① 인터페이스는 객체 사용 설명서 역할을 한다.
② 구현 클래스가 인터페이스의 추상 메소드에 대한 실체 메소드를 가지고 있지 않으면 추상 클래스가 된다.
③ 인터페이스는 인스턴스 필드를 가질 수 있다.
④ 구현 객체는 인터페이스 타입으로 자동 변환된다.


6.인터페이스와 클래스가 다른 점은 무엇입니까?
 다중 / 단일
 인터페이스 모든 메소드와 변수 public
 여러개의 클래스를 모아서 관리 => 인터페이스


7.인터페이스와 추상 클래스가 다른 점은 무엇입니까?
다중 / 단일


8.인터페이스의 장점 
다중 상속 (구현)
표준화 가능



9. 다음 중 인터페이스의 장점이 아닌 것은? (390page 참조)

a. 표준화를 가능하게 해준다.
b. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
c. 독립적인 프로그래밍이 가능하다.
d. 다중상속을 가능하게 해준다.
e. 패키지간의 연결을 도와준다. => import
---------------------- 


10.다음 중 틀린 것은?

a. 필드는 초기화하지 않아도 된다.=>  int =>0 /double => 0.0/ String=>null/ boolean => false
b. 클래스에 생성자가 없어도 된다. =>컴파일러가 자동으로 기본생성자 추가
c. 생성자는 일반적으로 필드를 초기화한다. 
   생성자의 역할 
   = 객체 생성시에 호출(생성자는 반드시 한개 이상이 필요하다)
   = 멤버변수에 대한 초기화
   = 클래스명과 동일 / 리턴형이 없다. 접근지정어는 보통 public
   = 오버로딩을 지원한다(여러개 생성자가 있을 수 있다.)
   = 초기화
     1) 명시적 초기화
     2) 구현후에 초기값 대입 => 파일읽기, 제어문이용, 데이터베이스이용
        초기화블록
        생성자=> 주로 사용
d. 필드는 생성자보다 먼저 선언해야 한다. =>  class 설계순서는 상관없다.
-----------------------------



11. 상속을 설명한 것이다. 틀린 것은?
 
a. 모든 클래스의 최상위 클래스는 Object이다.
b. 부모 객체를 자식 클래스 타입의 변수에 대입할 수 있다. (X) Child c = new Parent(); ==> 오류 Parent > Child
-----------------------------------------     ----- -   ------------ Parent 객체 생성
                                                    의 변수
                                              자식클래스타입
c. 부모 클래스의 private 메소드를 자식 클래스가 오버라이딩할 수 없다.
d. 부모 클래스를 상속하려면 extends 키워드가 필요하다.



12. 다음 코드가 있다. 밑줄 그은 곳에 적절하지 않은 코드는?
 
class Car {
    public String name;
    protected String color;
    private  int model;
}
 
class SportsCar extends Car {
    boolean turbo;
}
 
public class CarTest {
    public static void main(String[] args) {
        SportsCar s = new SportsCar();
        ______________________
    }
}
 
a. s.name = "ferrari";
b. s.color = "red";
c. s.model = 105;
-----------------
d. s.turbo = true;


13.         동일클래스          다른패키지            자식클래스            전체
        ------------------------------------------------------------------
  public     O                 O                  O                O 
        ------------------------------------------------------------------
protected    O                 O                  O           
        --------------------- ---------------------------------------------
 default     O                O 
        ------------------------------------------------------------------
 private     O    
        ------------------------------------------------------------------
 
 
 14. 다음과 같은 부모 클래스와 자식 클래스가 있다 틀린 곳을 찾으시오
 
class Person {
    void name() { }
    protected void number() { }
    private void secret() { }
}
 
class Student extends Person {
    public void name() { }
    void number() { } ==> 접근지정어 축소 불가
    ------------
    private void secret() { }
    -------------------------
}


15. 인터페이스를 설명한 것이다. 틀린 것은?
 
a. 인터페이스는 인스턴스 변수를 포함할 수 없다.
b. 인터페이스는 생성자를 포함할 수 없다.
c. 인터페이스는 상수를 포함할 수 없다.
-----------------------------
d. 인터페이스의 모든 멤버는 public으로 공개된다.



16. 다음은 인터페이스와 구현 클래스를 정의한 코드이다. 빈칸에 적절한 내용은?
 
interface A{
    void isPrint();
}
 
class B _implements A_ {
    public void isPrint() {
        System.out.println(“OK");
    }
}

 
17. Printable는 인터페이스이다. 다음 코드에서 잘못된 행을 모두 찾으시오.
 
interface Printable {
    String toner; => 초기화.
    abstract void print();
}
 
public class PrintableTest extends Printable {
                           -------
                           implements
    public static void main(String[] args) {
        //new Printable(); 삭제
        new PrintableTest(); => PrintableTest p = new PrintableTest()
        p.print();
        
         public void print() 
         {
             System.out.println("Printing..."); //구현
         }
    }
 
    
}

 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

package com.sist.exception;
/*
 *    final 클래스 => 종단 클래스(java.lang) (String,Math...등을 extends(상속) 할때 오류 발생. )
 *    ---------- 확장을 할 수 없다 (있는 그대로 사용)
 *    java.lang  상위 클래스가 될 수 없다.
 *    java.util
 *    java.io
 *    java.net
 *    java.text
 *    ---------- 기본 라이브러리
 *    java.sql, javax.http.servlet.* javax.xml
 *      오라클          브라우저
 *    
 *    4. 오버라이딩 (상속의 기본) => 변경해서 사용(다형성)
 *       
 *       객체지향의 3대 요소
 *       1. 데이터 보호 목적
 *          캡슐화 : 변수를 은닉화 => 메소드를 통해서 접근이 가능하게 만든다.
 *                 ---------               --------
 *                  private                 public  
 *                  => 변수는 2가지 기능만 수행
 *                      1) 메모리 저장 setter
 *                      2) 메모리에서 데이터 읽기 getter
 *                  => 모든 멤버변수 : private
 *                  => 모든 메소드(생성자를 포함한) : public => 다른 클래스와 연결이 가능
 *          접근지정어
 *          -------
 *          1) private : 자신의 클래스에서만 사용이 가능하다.(은닉화)
 *                       다른 클래스에서는 접근이 불가능하다.        
 *          2) default : 같은 패키지에서만 접근이 가능하다
 *          3) public : 공개(패키지 상관없이 모든 클래스에 접근이 가능)                
 *       
 *       
 *       2. 재사용하는 목적 : 상속 포함
 *          class A
 *     <상속>class B extends A => A가 가지고 있는 모든 내용을 가지고 온다.
 *                  ------- A의 내용을 변경해서 사용,추가가 가능하다.
 *                          상속을 내린 클래스 A > B 상속을 받은 클래스
 *                          A a = new A();
 *                          B b = new B();
 *                          A a2 = new B(); => 묵시적 형변환 (자동형변환)
 *                          B b2= (B)a2; => 명시적 형변환 (강제형변환)
 *                                          ---------
 *                                          라이브러리에서 많이 사용=> 예) 클래스를 저장해서 관리(클래스) => Collection
 *                                          
 *                          -------------> 추상클래스/ 인터페이스 (메모리 할당이 안되는 미완성클래스)
 *                                         ---------------                 -------- 메소드가 선언만 되고, 구현이 안된상태
 *                                         메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다.
 *                                         => 설계, 같은 기능 모음(처리를 프로그램에 맞게 할때)
 *                          
 *     <포함>class B
 *          {
 *             A a = new A(); => 특별한 경우가 아니면 재정의 하지 않는다.
 *          }                    그대로 가져다 쓴다.
 *                  
 *       
 *       
 *       3. 수정,추가 목적
 *       
 *                         
 *       -----------------------------------------------
 *               추가 (오버로딩)        수정(오버라이딩)
 *       -----------------------------------------------
 *        관계      한개의 클래스            상속관계
 *                 상속관계
 *       -----------------------------------------------
 *        메소드명     동일                  동일
 *       -----------------------------------------------
 *        매개변수   갯수나 데이터형이           동일
 *                  다르다            
 *       -----------------------------------------------
 *        리턴형      관계없음                동일
 *       -----------------------------------------------
 *        접근지정어   관계없음               확장가능
 *       -----------------------------------------------
 *        사용처      생성자             인터페이스/추상클래스
 *       -----------------------------------------------
 *          *** 상속
 *              1) 호출 ==> 상위클래스의 생성자가 먼저 호출(기본생성자)
 *                 class A
 *                 {
 *                 // public A(){} 
 *                    public A(int a){}
 *                 }
 *                 class B extends A
 *                 {
 *                    public B (int a, int b){}
 *                 }
 *                 
 *                 B b = new B(); => 상위클래스의 기본생성자가 먼저 호출된다.
 *                                   상위클래스의 기본생성자가 없을시에 오류 발생.
 *              
 *              2) 예외조건(상속이 안되는 조건) : static , 생성자, 초기화블럭, private 
 *              
 *                 class A
 *                 class B extends A
 *                 class D extends B
 *                 clsss E extends B
 *                 ------------------
 *                 A a= new A();
 *                 A a= new B();
 *                 B b= new B();
 *                 B b= new D();
 *                 B b= new E();
 *                 --------------
 *                 A a= new B();
 *                 B b= (B)a;
 *       --------------------------------------------------------
 *       클래스의 종류
 *       = 추상클래스
 *       = 인터페이스 => 추상클래스의 단점을 보완 (클래스와 동일하게 취급)
 *         *** 클래스(단일 상속)/ 인터페이스(다중 구현)
 *       공통=> 설계도(구현이 안된상태) => 미완성 클래스 (자신이 메모리 할당을 할 수 없다.)       
 *          => 여러개의 관련된 클래스를 모아서 한개의 객체명으로 제어
 *       ---------------------------------------------------------------
 *                   추상 클래스                       인터페이스
 *       ---------------------------------------------------------------
 *        상속관계      단일 상속                       다중 상속(구현)
 *       ---------------------------------------------------------------
 *        상속키워드     extends                      implements
 *       ---------------------------------------------------------------
 *        멤버변수      인스턴스변수                    상수형 변수(final)
 *                    정적변수
 *       ---------------------------------------------------------------
 *        메소드        구현된메소드                    구현이 안된 메소드
 *                  구현이 안된 메소드
 *       ---------------------------------------------------------------
 *        기법                         오버라이딩
 *       --------------------------------------------------------------- 
 *        형식      
 *                  <추상클래스>
 *                  [접근지정어] abstract class ClassName
 *                  {
 *                     --------------------------
 *                      변수
 *                        인스턴스 변수
 *                        static 변수(정적변수)
 *                     --------------------------
 *                      메소드
 *                        구현된 메소드
 *                        [접근지정어] 리턴형 메소드명(매개변수..)
 *                        {
 *                        }
 *                        구현이 안된 메소드(선언만)
 *                        [접근지정어] abstract 리턴형 메소드명(매개변수..);
 *                                 ---------
 *                     --------------------------
 *                      생성자, 오버로딩이 가능
 *                     --------------------------
 *                  }
 *                  
 *                  <인터페이스>
 *                  [접근지정어] interface InterfaceName
 *                  {
 *                      --------------------------
 *                       변수선언 (상수형 변수)
 *                       int a=10; => 값을 명시적으로 지정
 *                       => (public static final) int a=10;
 *                            ----------------- 자동추가
 *                      --------------------------
 *                       구현이 안된 메소드 목록
 *                       void display();
 *                       => (public abstract) void display();
 *                           --------------- 자동추가
 *                      --------------------------
 *                       구현한 메소드 목록
 *                  (일반)default void aaa(){}
 *                       => (public) default void aaa(){}
 *                       static void bbb(){}
 *                       => (public) static void bbb(){}
 *                       
 *                      --------------------------
 *                      
 *                  }
 *                  ==> 인터페이스는 변수나 메소드가 public(연결 목적 => 언제든 연결이 가능)
 *       ---------------------------------------------------------------
 *       
 *       상속    
 *                 extends 
 *       interface =======> interface
 *                 implements 
 *       interface ==========> class  
 *       
 *       다중상속
 *       class A implements 인터페이스, 인터페이스 ...
 *           
 */
import java.util.*;
abstract class C
{
	C(){}
	C(int a){}
}
class A
{
	int a=10;
	String name="홍길동";
	public A() {}
	public A(int a)
	{
		this.a=a;
	}
	
}
class B extends A
{
	int b=20;
	public B()
	{
		super(); // public A() {} 호출
	}
}
class AAA 
{
	
	public void display() {
		
	}
}
class BBB extends AAA
{
	int a;
	int b;
	public void display() 
	{
		System.out.println("재정의된 메소드");
	}
}
public class 정리_7장 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*List list = new ArrayList<>();
		list.add("");
		list.add(1);
		list.add(new 정리_7장());
		String s = (String)list.get(0);*/ //=> 명시적 형변환(강제형변환) =>list.get(0)의 리턴값이 Object이기 때문에
		String s1="Hello";
		String s2="Hello";
		String s3 = new String("Hello");
		if(s1==s2)
			System.out.println("true");
		
		AAA aa= new BBB();
		aa.display();
		/*
		 *  AAA 에 있는 데이터만 사용하되 , BBB에 의해 재정의된 메소드만 사용하겠다.
		 */

	}

}
